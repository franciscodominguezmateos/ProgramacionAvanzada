/*
 * shader.h
 *
 *  Created on: 3 Jan 2020
 *      Author: Francisco Dominguez
 *  Inspired by: https://www.youtube.com/user/ThinMatrix
 */

#ifndef SHADER_H_
#define SHADER_H_
#include "util.h"
#include "vector3d.h"

// In order to use GLSL
#define GL_GLEXT_PROTOTYPES
#include <GL/glut.h>
// In order to use GLSL
#include <GL/glext.h>
struct Vec2{float x,y;};
struct Vec3{float x,y,z;};
struct Vec4{float x,y,z,w;};

class Uniform{
	static const GLint NOT_FOUND=-1;
	string name;
	GLint location;
public:
	Uniform(string n):name(n),location(NOT_FOUND){}
	void setLocation(GLuint programID){
		location=glGetUniformLocation(programID,name.c_str());
		if(location == GL_INVALID_VALUE)
			throw runtime_error("Error in Uniform::storeUniformLocation() programID is not a value generated by OpenGL");
		if(location == GL_INVALID_OPERATION)
			throw runtime_error("Error in Uniform::storeUniformLocation() programID program is not a program object");
		if(location == GL_INVALID_OPERATION)
			throw runtime_error("Error in Uniform::storeUniformLocation() programID has not been successfully linked");
		if(location == NOT_FOUND)
			throw runtime_error("Error in Uniform::storeUniformLocation() uniform name="+name+" not found in programID");
	}
	inline GLint getLocation(){return location;}

	inline void load(GLfloat v){glUniform1f(location,v);}
	inline Uniform &operator=(GLfloat f){load(f);return *this;}

	inline void load(GLint   v){glUniform1i(location,v);}
	inline Uniform &operator=(GLint f){load(f);return *this;}

	inline void load(bool v){glUniform1f(location,v?1:0);}
	inline Uniform &operator=(bool f){load(f);return *this;}

	inline void load(GLfloat x,GLfloat y){glUniform2f(location,x,y);}
	inline void load(Vec2 v){load(v.x,v.y);}
	inline Uniform &operator=(Vec2 f){load(f);return *this;}

	inline void load(GLfloat x,GLfloat y,GLfloat z){glUniform3f(location,x,y,z);}
	inline void load(Vec3 v){load(v.x,v.y,v.z);}
	inline Uniform &operator=(Vec3 f){load(f);return *this;}
	inline void load(Vector3D v){load((GLfloat)v.getX(),(GLfloat)v.getY(),(GLfloat)v.getZ());}
	inline Uniform &operator=(Vector3D f){load(f);return *this;}

	inline void load(GLfloat x,GLfloat y,GLfloat z,GLfloat w){glUniform4f(location,x,y,z,w);}
	inline void load(Vec4 v){load(v.x,v.y,v.z,v.w);}
	inline Uniform &operator=(Vec4 f){load(f);return *this;}

	inline void load(vector<GLfloat> v){
		GLfloat* d=v.data();
		if(v.size()== 2) glUniform2fv(location,1,d);
		if(v.size()== 3) glUniform3fv(location,1,d);
		if(v.size()== 4) glUniform4fv(location,1,d);
		//if(v.size()== 4) glUniformMatrix2fv(location,1,true,d);
		if(v.size()== 9) glUniformMatrix3fv(location,1,true,d);
		if(v.size()==16) glUniformMatrix4fv(location,1,false,d);
	}
	inline Uniform &operator=(vector<GLfloat> v){load(v);return *this;}

	inline void load(Mat &m0){
		Mat_<GLfloat> m(m0);
		GLfloat* d=(GLfloat*)m.data;
		if(m.cols==2 && m.rows==2) glUniformMatrix2fv(location,1,true,d);
		if(m.cols==3 && m.rows==3) glUniformMatrix3fv(location,1,true,d);
		if(m.cols==4 && m.rows==4) glUniformMatrix4fv(location,1,true,d);
	}
	inline Uniform &operator=(Mat f){load(f);return *this;}

	inline void load(vector<Mat> &v){
		if(!v.empty()){
			//take as granted that all Mat are same dimension
			Mat_<GLfloat> m(v[0]);
			unsigned int stride=m.cols*m.rows;
			unsigned int n=v.size();
			GLfloat* d=new GLfloat[n*stride];
			unsigned int idx=0;
			for(Mat &m:v)
				for(unsigned int i=0;i<m.rows;i++)
					for(unsigned int j=0;j<m.cols;j++)
						d[idx++]=m.at<GLfloat>(i,j);
			if(m.cols==2 && m.rows==2) glUniformMatrix2fv(location,n,false,d);
			if(m.cols==3 && m.rows==3) glUniformMatrix3fv(location,n,false,d);
			if(m.cols==4 && m.rows==4) glUniformMatrix4fv(location,n,false,d);
			delete[] d;
		}
	}
	inline Uniform &operator=(vector<Mat> &v){load(v);return *this;}
};
class UniformFloat: public Uniform{
	GLfloat value;
	bool used;
public:
	UniformFloat(string name):Uniform(name),used(false){}
	void load(GLfloat v){
		if(!used || value!=v){
			glUniform1f(getLocation(),v);
			used=true;
			value=v;
		}
	}
};
class GLSLVBO{
	static const GLuint BYTES_PER_INT=4;
	static const GLuint BYTES_PER_FLOAT=4;
	GLuint id;
	GLuint type;
public:
	GLSLVBO():id(0),type(0){}
	GLSLVBO(GLuint type):type(type){
		glGenBuffers(1,&id);}
	inline void bind(){glBindBuffer(type,id);}
	inline void unbind(){glBindBuffer(type,0);}
	inline void storeData(vector<GLfloat> &data){
		glBufferData(type,data.size()*BYTES_PER_FLOAT,data.data(),GL_STATIC_DRAW);}
	inline void storeData(vector<GLint>  &data){
		glBufferData(type,data.size()*BYTES_PER_INT  ,data.data(),GL_STATIC_DRAW);}
	inline void deleleteBuffer(){
		glDeleteBuffers(1,&id);}
};
class GLSLVAO{
	static const GLuint BYTES_PER_INT=4;
	static const GLuint BYTES_PER_FLOAT=4;
	GLuint id;
	vector<GLSLVBO> VBOs;
	GLSLVBO indexVBO;
	GLuint indexCount;
public:
	GLSLVAO():id(0),indexCount(0){}
	inline void init(){
		glGenVertexArrays(1, &id);
		bind();
	}
	inline void bind(){glBindVertexArray(id);}
	inline void unbind(){glBindVertexArray(0);}
	inline void bind(vector<GLuint> &attributes){
		bind();
		for(GLuint i:attributes) glEnableVertexAttribArray(i);
	}
	inline void bind(GLuint atts...){
		vector<GLuint> attributes(atts);
		bind(attributes);
	}
	inline void bindAll(){
		bind();
		for(GLuint i=0;i<VBOs.size();i++) glEnableVertexAttribArray(i);
	}
	inline void unbind(vector<GLuint> &attributes){
		for(GLuint i:attributes) glDisableVertexAttribArray(i);
		unbind();
	}
	inline void unbind(GLuint atts...){
		vector<GLuint> attributes(atts);
		unbind(attributes);
	}
	inline void unbindAll(){
		for(GLuint i=0;i<VBOs.size();i++) glDisableVertexAttribArray(i);
		unbind();
	}
	void createIndexBuffer(vector<GLint> &indices){
		//This is already done in the constructor
		indexVBO=GLSLVBO(GL_ELEMENT_ARRAY_BUFFER);
		indexVBO.bind();
		indexVBO.storeData(indices);
		indexCount=indices.size();
	}
	void createAttribute(GLuint attribute,vector<GLfloat> &data,GLuint attrSize){
		GLSLVBO vbo(GL_ARRAY_BUFFER);
		vbo.bind();
		vbo.storeData(data);
		//glVertexAttribPointer(attribute,attrSize,GL_FLOAT,GL_FALSE,attrSize*BYTES_PER_FLOAT,0);
		glVertexAttribPointer(attribute,attrSize,GL_FLOAT,GL_FALSE,0,0);
		vbo.unbind();
		VBOs.push_back(vbo);
	}
	void createAttribute(GLuint attribute,vector<GLint> &data,GLuint attrSize){
		GLSLVBO vbo(GL_ARRAY_BUFFER);
		vbo.bind();
		vbo.storeData(data);
		//glVertexAttribIPointer(attribute,attrSize,GL_INT,attrSize*BYTES_PER_INT,0);
		glVertexAttribIPointer(attribute,attrSize,GL_INT,0,0);
		vbo.unbind();
		VBOs.push_back(vbo);
	}
	void deleteVBOs(){
		glDeleteVertexArrays(1,&id);
		for(GLSLVBO &vbo:VBOs) vbo.deleleteBuffer();
		indexVBO.deleleteBuffer();
	}
};

class GLSLShader{
	GLuint shaderID;
public:
	GLSLShader(GLuint shaderType):shaderID(glCreateShader(shaderType)){	}
	GLuint compileFromFileName(string fileName){
		cout << "Compiling shader: "<<fileName<<endl;
		string sourceCode;
		ifstream sf(fileName);
		sf>>sourceCode;
		return compile(sourceCode);
	}
	GLuint compile(string sourceCode){
		GLint Result = GL_FALSE;
		int InfoLogLength;

		// Compile shader
		char const * sourcePointer = sourceCode.c_str();
		glShaderSource(shaderID, 1, &sourcePointer , NULL);
		glCompileShader(shaderID);

		// Check errors
		glGetShaderiv(shaderID, GL_COMPILE_STATUS, &Result);
		glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, &InfoLogLength);
		if ( InfoLogLength > 0 ){
			std::vector<char> shaderErrorMessage(InfoLogLength+1);
			glGetShaderInfoLog(shaderID, InfoLogLength, NULL, &shaderErrorMessage[0]);
			throw runtime_error(&shaderErrorMessage[0]);
		}
		return shaderID;
	}
};
class GLSLShaderProgram {
	GLuint programID;
public:
	GLSLShaderProgram(){}
	void compileFromFileNames(string vertexFileName,string fragmentFileName){
		cout << vertexFileName <<endl;
		cout << fragmentFileName<<endl;
		// Compiling vertes shader
		GLSLShader vs(GL_VERTEX_SHADER);
	    GLuint VertexShaderID=vs.compileFromFileName(vertexFileName);
	    // Compiling frame shader
		GLSLShader fs(GL_FRAGMENT_SHADER);
		GLuint FragmentShaderID=fs.compileFromFileName(fragmentFileName);
		GLint Result = GL_FALSE;
		int InfoLogLength;

		// Vincular el programa por medio del ID
		printf("Linking program\n");
		programID = glCreateProgram();
		glAttachShader(programID, VertexShaderID);
		glAttachShader(programID, FragmentShaderID);
		glLinkProgram(programID);

		// Revisar el programa
		glGetProgramiv(programID, GL_LINK_STATUS, &Result);
		glGetProgramiv(programID, GL_INFO_LOG_LENGTH, &InfoLogLength);
		if ( InfoLogLength > 0 ){
			std::vector<char> ProgramErrorMessage(InfoLogLength+1);
			glGetProgramInfoLog(programID, InfoLogLength, NULL, &ProgramErrorMessage[0]);
			throw runtime_error(&ProgramErrorMessage[0]);
		}
		glDetachShader(programID, VertexShaderID);
		glDetachShader(programID, FragmentShaderID);

		glDeleteShader(VertexShaderID);
		glDeleteShader(FragmentShaderID);
	}
	~GLSLShaderProgram(){
		stop();
		glDeleteProgram(programID);
	}
	void setUniformsLocation(vector<Uniform> &uniforms){
		for(Uniform &u:uniforms)
			u.setLocation(programID);
	}
	void bindAttribute(GLuint attribID,string s){
		glBindAttribLocation(programID,attribID,s.c_str());
	}
	void start(){glUseProgram(programID);}
	void stop(){glUseProgram(0);}
	inline GLuint id(){return programID;}
};

#endif /* SHADER_H_ */
