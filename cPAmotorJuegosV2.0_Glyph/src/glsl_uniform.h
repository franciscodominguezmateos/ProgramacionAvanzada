/*
 * glsl_uniform.h
 *
 *  Created on: 14 Jan 2021
 *      Author: Francisco Dominguez
 */
#pragma once
class Uniform;
using UniformPtr=Uniform*;

class Uniform{
	static const GLint NOT_FOUND=-1;
	string name;
	GLint location;
public:
	Uniform(string n=""):name(n),location(NOT_FOUND){}
	//void setLocation(GLSLShaderProgram &p){
	//	setLocation(p.id());
	//}
	void setLocation(GLuint programID){
		location=glGetUniformLocation(programID,name.c_str());
		if(location == GL_INVALID_VALUE)
			throw runtime_error("Error in Uniform::storeUniformLocation() programID is not a value generated by OpenGL");
		if(location == GL_INVALID_OPERATION)
			throw runtime_error("Error in Uniform::storeUniformLocation() programID program is not a program object");
		if(location == GL_INVALID_OPERATION)
			throw runtime_error("Error in Uniform::storeUniformLocation() programID has not been successfully linked");
		if(location == NOT_FOUND)
			throw runtime_error("Error in Uniform::storeUniformLocation() uniform name="+name+" not found in programID");
	}
	inline GLint getLocation(){return location;}
    // FLOAT
	inline void load(GLfloat v){glUniform1f(location,v);}
	inline Uniform &operator=(GLfloat f){load(f);return *this;}
    // INT
	inline void load(GLint   v){glUniform1i(location,v);}
	inline Uniform &operator=(GLint f){load(f);return *this;}
    // BOOLEAN
	inline void load(bool v){glUniform1f(location,v?1:0);}
	inline Uniform &operator=(bool f){load(f);return *this;}
    // Vector 2D
	inline void load(GLfloat x,GLfloat y){glUniform2f(location,x,y);}
	inline void load(Vec2 v){load(v.x,v.y);}
	inline Uniform &operator=(Vec2 f){load(f);return *this;}
    // Vector 3D
	inline void load(GLfloat x,GLfloat y,GLfloat z){glUniform3f(location,x,y,z);}
	inline void load(Vec3 v){load(v.x,v.y,v.z);}
	inline Uniform &operator=(Vec3 f){load(f);return *this;}
	inline void load(Vector3D v){load((GLfloat)v.getX(),(GLfloat)v.getY(),(GLfloat)v.getZ());}
	inline Uniform &operator=(Vector3D f){load(f);return *this;}
    // Vector 4D
	inline void load(GLfloat x,GLfloat y,GLfloat z,GLfloat w){glUniform4f(location,x,y,z,w);}
	inline void load(Vec4 v){load(v.x,v.y,v.z,v.w);}
	inline Uniform &operator=(Vec4 f){load(f);return *this;}
    // Vector case size: 2->2D 3->3D 4->4D 9->Mat3x3 16->Mat4x4
	// Matrices here are in OpenGL format in column mayor.
	// that is the reason of 'false' in transpose parameter
	inline void load(vector<GLfloat> v){
		GLfloat* d=v.data();
		if(v.size()== 2) glUniform2fv(location,1,d);
		if(v.size()== 3) glUniform3fv(location,1,d);
		if(v.size()== 4) glUniform4fv(location,1,d);
		//if(v.size()== 4) glUniformMatrix2fv(location,1,true,d);
		if(v.size()== 9) glUniformMatrix3fv(location,1,false,d);
		if(v.size()==16) glUniformMatrix4fv(location,1,false,d);
	}
	inline Uniform &operator=(vector<GLfloat> v){load(v);return *this;}
    // Matrix 2x2, 3x3 and 4x4
	// Matrices are in OpenCV or traditional order mayor row not in OpenGL format
	// that is the reason of 'true' in transpose parameter
	inline void load(Mat m0){
		Mat_<GLfloat> m(m0);
		GLfloat* d=(GLfloat*)m.data;
		if(m.cols==2 && m.rows==2) glUniformMatrix2fv(location,1,true,d);
		if(m.cols==3 && m.rows==3) glUniformMatrix3fv(location,1,true,d);
		if(m.cols==4 && m.rows==4) glUniformMatrix4fv(location,1,true,d);
	}
	inline Uniform &operator=(Mat f){load(f);return *this;}
    // Vector of Matrix 2x2, 3x3 and 4x4 for joints
	inline void load(vector<Mat> v){
		if(!v.empty()){
			//take as granted that all Mat are same dimension
			Mat_<GLfloat> m(v[0]);
			unsigned int stride=m.cols*m.rows;
			unsigned int n=v.size();
			GLfloat* d=new GLfloat[n*stride];
			unsigned int idx=0;
			for(Mat &m:v)
				for(int i=0;i<m.rows;i++)
					for(int j=0;j<m.cols;j++)
						d[idx++]=(GLfloat)m.at<GLfloat>(i,j);
			if(m.cols==2 && m.rows==2) glUniformMatrix2fv(location,n,true,d);
			if(m.cols==3 && m.rows==3) glUniformMatrix3fv(location,n,true,d);
			if(m.cols==4 && m.rows==4) glUniformMatrix4fv(location,n,true,d);
			delete[] d;
		}
	}
	inline Uniform &operator=(vector<Mat> &v){load(v);return *this;}
};




